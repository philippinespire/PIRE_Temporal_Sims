// Keywords: nonWF, non-Wright-Fisher, Wright-Fisher, non-overlapping generations, discrete generations, random mating

initialize() {
// Initialize model type (non-Wright-Fisher)
	initializeSLiMModelType("nonWF");
// Use tree sequence recording
	initializeTreeSeq();
// Two differentiated sexes
	initializeSex("A");
// Demographic variables - COMMENTED OUT since these will be fed to SLiM in a python script as variables
//	defineConstant("Nhistoric",1000);
//	defineConstant("Tdecline",300);
//	defineConstant("lambda",0.95);
// Life table and stable age distribution	
defineConstant("L",c(0.5,0.36,0.25,0.2,0.15,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.4,0.6,0.7,0.8,0.9,1));
	defineConstant("a1",asInteger((1-L[0])*Nhistoric));
	defineConstant("a2",asInteger((1-L[1])*a1));
	defineConstant("a3",asInteger((1-L[2])*a2));
	defineConstant("a4",asInteger((1-L[3])*a3));
	defineConstant("a5",asInteger((1-L[4])*a4));
	defineConstant("a6",asInteger((1-L[5])*a5));
	defineConstant("a7",asInteger((1-L[6])*a6));
	defineConstant("a8",asInteger((1-L[7])*a7));
	defineConstant("a9",asInteger((1-L[8])*a8));
	defineConstant("a10",asInteger((1-L[9])*a9));
	defineConstant("a11",asInteger((1-L[10])*a10));
	defineConstant("a12",asInteger((1-L[11])*a11));
	defineConstant("a13",asInteger((1-L[12])*a12));
	defineConstant("a14",asInteger((1-L[13])*a13));
	defineConstant("a15",asInteger((1-L[14])*a14));
	defineConstant("a16",asInteger((1-L[15])*a15));
	defineConstant("a17",asInteger((1-L[16])*a16));
	defineConstant("a18",asInteger((1-L[17])*a17));
	defineConstant("a19",asInteger((1-L[18])*a18));
	defineConstant("a20",asInteger((1-L[18])*a19));
	defineConstant("Ninit",Nhistoric+a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12+a13+a14+a15+a16+a17+a18+a19+a20);
// Using 25 chromosomes (somewhere around the median for vertebrates). Changing this would necessitate alterations to the chromosome setup loop below but could be done. 
	defineConstant("nchrom",25);
// Mutation rate is not important since we will be setting it to zero and adding mutations later
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = F;

// Setting up chromosome structure: 25 chromosomes, 30 Mb each. Recombination rate is 1e-8 within chromosomes and 0.5 among chromosomes
	for (locus in 0:(nchrom-1)){
	geType=initializeGenomicElementType(locus, m1, 1.0);
	initializeGenomicElement(geType, locus*30000000, locus*30000000+29999999);
	}
	initializeMutationRate(0);
	lengths=rep(30000000,48);
   chrlistd=sort(rep(seq(1,24),2));
   breakpointd=lengths*chrlistd;
   offset=rep(c(1,0),24);
   breaks=c(breakpointd-offset,749999999);
   rates=c(1e-8,rep(c(0.5,1e-8),24));
	initializeRecombinationRate(rates,breaks);

}

// Random mating with a specified # of offspring. For each offspring randomly choose one male and one female parent. Recording parent IDs in order to output distribution of reproductive success later. In this reproduction call I am also outputting some info about # of breeding-age individuals and distribution of parentage.
reproduction(p1,"F") {
	K = sim.getValue("K");
	femalelist=NULL;
	malelist=NULL;
	for (i in seqLen(asInteger(K)))
	{
		female = p1.sampleIndividuals(1,sex="F",minAge=6);
		femalelist=c(femalelist,female.index);
		male = p1.sampleIndividuals(1,sex="M",minAge=6);
		malelist=c(malelist,male.index);
		p1.addCrossed(female, male);
	}
	breederdat=c("generation:",sim.generation,"num_breedingage_males:",sum(p1.individuals.sex == "M" & p1.individuals.age > 5),"num_breedingage_females:",sum(p1.individuals.sex == "F" & p1.individuals.age > 5));
	breedline=paste(breederdat,sep=" ");
	agedat=c("generation:",sim.generation,"age1:",sum(p1.individuals.age == 1),"age2:",sum(p1.individuals.age == 2),"age3:",sum(p1.individuals.age == 3),"age4:",sum(p1.individuals.age == 4),"age5:",sum(p1.individuals.age == 5),"age6:",sum(p1.individuals.age == 6),"age7:",sum(p1.individuals.age == 7),"age8:",sum(p1.individuals.age == 8),"age9:",sum(p1.individuals.age == 9),"age10:",sum(p1.individuals.age == 10),"age11:",sum(p1.individuals.age == 11),"age12:",sum(p1.individuals.age == 12),"age13:",sum(p1.individuals.age == 13),"age14:",sum(p1.individuals.age == 14),"age15:",sum(p1.individuals.age == 15),"age16:",sum(p1.individuals.age == 16),"age17:",sum(p1.individuals.age == 17),"age18:",sum(p1.individuals.age == 18),"age19:",sum(p1.individuals.age == 19),"age20:",sum(p1.individuals.age == 20));
	ageline=paste(agedat,sep=" ");
	maledat=c("generation:",sim.generation,"male_parents:",malelist);
	maleline=paste(maledat,sep=" ");
	femaledat=c("generation:",sim.generation,"female_parents:",femalelist);
	femaleline=paste(femaledat,sep=" ");
	writeFile(sim.getValue("BOF"),breedline,append=T);
	writeFile(sim.getValue("AOF"),ageline,append=T);
	writeFile(sim.getValue("MOF"),maleline,append=T);
	writeFile(sim.getValue("FOF"),femaleline,append=T);
	self.active = 0;
}

// First generation: set # of offspring to and K Nhistoric, set distribution of ages to stable age distribution
1 early() {
	sim.setValue("K", Nhistoric);
	sim.setValue("AOF", AOutFile);
	sim.setValue("BOF", BOutFile);
	sim.setValue("MOF", MOutFile);
	sim.setValue("FOF", FOutFile);
	sim.setValue("TSOF", TSOutFile);
	sim.addSubpop("p1", Ninit);
p1.individuals.age=sample(c(rep(0,Nhistoric),rep(1,a1),rep(2,a2),rep(3,a3),rep(4,a4),rep(5,a5),rep(6,a6),rep(7,a7),rep(8,a8),rep(9,a9),rep(10,a10),rep(11,a11),rep(12,a12),rep(13,a13),rep(14,a14),rep(15,a15),rep(16,a16),rep(17,a17),rep(18,a18),rep(19,a19),rep(20,a20)),Ninit);
}

// Population decline: if simulation time is greater than or equal to Tdecline, exponential reduction in # of offspring. Can have a stable population if Tdecline is set to > 420.
early(){
	if (sim.generation > Tdecline) {
		sim.setValue("K",round(sim.getValue("K")*lambda));
		}
}

// Survival for overlapping generations based on life table
early()
{		
	inds = p1.individuals;
	ages = inds.age;
	mortality = L[ages];
	survival = 1 - mortality;
	inds.fitnessScaling = survival;
}

// Tree sequence - remember individuals from each potential sampling time point. NOTE - may not have to remember all individuals. But tree-seq is cheap so remembering all may not be too onerous.

300 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

330 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

360 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

390 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

420 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

// OUTPUT FILES for treeseq

420 late() { sim.treeSeqOutput(sim.getValue("TSOF")); }
