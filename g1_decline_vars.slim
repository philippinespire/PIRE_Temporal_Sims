// Keywords: nonWF, non-Wright-Fisher, non-overlapping generations, discrete generations, random mating

initialize() {
// Initialize model type (non-Wright-Fisher, although this has many aspects of a Wright-Fisher model 
	initializeSLiMModelType("nonWF");
// Use tree sequence recording
	initializeTreeSeq();
// Two differentiated sexes
	initializeSex("A");
// Demographic variables - COMMENTED OUT since these will be fed to SLiM in a python script as variables
//	defineConstant("Nhistoric",1000);
//	defineConstant("Tdecline",300);
//	defineConstant("lambda",0.95);
// Using 25 chromosomes (somewhere around the median for vertebrates). Changing this would necessitate alterations to the chromosome setup loop below but could be done. 
	defineConstant("nchrom",25);
// Mutation rate is not important since we will be setting it to zero and adding mutations later
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = F;

// Setting up chromosome structure: 25 chromosomes, 30 Mb each. Recombination rate is 1e-8 within chromosomes and 0.5 among chromosomes
	for (locus in 0:(nchrom-1)){
	geType=initializeGenomicElementType(locus, m1, 1.0);
	initializeGenomicElement(geType, locus*30000000, locus*30000000+29999999);
	}
	initializeMutationRate(0);
	lengths=rep(30000000,48);
   chrlistd=sort(rep(seq(1,24),2));
   breakpointd=lengths*chrlistd;
   offset=rep(c(1,0),24);
   breaks=c(breakpointd-offset,749999999);
   rates=c(1e-8,rep(c(0.5,1e-8),24));
	initializeRecombinationRate(rates,breaks);
}

// Random mating with a specified # of offspring. For each offspring randomly choose one male and one female parent. Recording parent IDs in order to output distribution of reproductive success later. In this reproduction call I am also outputting some info about # of breeding-age individuals and distribution of parentage.
reproduction(p1,"F") {
	K = sim.getValue("K");
	femalelist=NULL;
	malelist=NULL;
	for (i in seqLen(asInteger(K)))
	{
		female = p1.sampleIndividuals(1,sex="F");
		femalelist=c(femalelist,female.index);
		male = p1.sampleIndividuals(1,sex="M");
		malelist=c(malelist,male.index);
		p1.addCrossed(individual, male);
	}
	breederdat=c("generation:",sim.generation,"num_breedingage_males:",sum(p1.individuals.sex == "M"),"num_breedingage_females:",sum(p1.individuals.sex == "F"));
	breedline=paste(breederdat,sep=" ");
	maledat=c("generation:",sim.generation,"male_parents:",malelist);
	maleline=paste(maledat,sep=" ");
	femaledat=c("generation:",sim.generation,"female_parents:",femalelist);
	femaleline=paste(femaledat,sep=" ");
	writeFile(sim.getValue("BOF"),breedline,append=T);
	writeFile(sim.getValue("MOF"),maleline,append=T);
	writeFile(sim.getValue("FOF"),femaleline,append=T);
	self.active = 0;
}

// First generation: set # of offspring and K to Nhistoric. Also had to set output files as simulation variable (not sure I had to do this in a previous version, but I think this is safer/ more reproducible?)  
1 early() {
	sim.setValue("K", Nhistoric);
	sim.setValue("BOF", BOutFile);
	sim.setValue("MOF", MOutFile);
	sim.setValue("FOF", FOutFile);
	sim.setValue("TSOF", TSOutFile);
	sim.addSubpop("p1", Nhistoric);
}

// Population decline: if simulation time is greater than or equal to Tdecline, exponential reduction in # of offspring. Can have a stable population if Tdecline is set to > 420.
early(){
	if (sim.generation >= Tdecline) {
		sim.setValue("K",round(sim.getValue("K")*lambda));
		}
}

// Survival for non-overlapping generations - all individuals from previous generation die at the end of time step
early()
{
	inds = sim.subpopulations.individuals;
	inds[inds.age > 0].fitnessScaling = 0.0;
}

// Tree sequence - remember individuals from each potential sampling time point. NOTE - may not have to remember all individuals. But tree-seq is cheap so remembering all may not be too onerous (and may be important for randomly generating samples/mutations later?

300 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

330 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

360 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

390 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

420 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

// OUTPUT FILES for treeseq

420 late() { sim.treeSeqOutput(sim.getValue("TSOF")); }
