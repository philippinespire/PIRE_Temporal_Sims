// Keywords: nonWF, non-Wright-Fisher, overlapping generations, random mating

initialize() {
// Initialize model type (non-Wright-Fisher)
	initializeSLiMModelType("nonWF");
// Use tree sequence recording
	initializeTreeSeq();
// Two differentiated sexes
	initializeSex("A");
// Demographic variables - COMMENTED OUT since these will be fed to SLiM in a python script as variables
//	defineConstant("Nhistoric",1000);
//	defineConstant("Tdecline",300);
//	defineConstant("lambda",0.95);
// Life table and stable age distribution	
	defineConstant("L",c(0.733,0.2,0.2,0.2,0.2,0.36,0.6,0.8,1));
	defineConstant("a1",asInteger((1-L[0])*Nhistoric));
	defineConstant("a2",asInteger((1-L[1])*a1));
	defineConstant("a3",asInteger((1-L[2])*a2));
	defineConstant("a4",asInteger((1-L[3])*a3));
	defineConstant("a5",asInteger((1-L[4])*a4));
	defineConstant("a6",asInteger((1-L[5])*a5));
	defineConstant("a7",asInteger((1-L[6])*a6));
	defineConstant("Ninit", Nhistoric+a1+a2+a3+a4+a5+a6+a7);
// Using 25 chromosomes (somewhere around the median for vertebrates). Changing this would necessitate alterations to the chromosome setup loop below but could be done. 
	defineConstant("nchrom",25);
// Mutation rate is not important since we will be setting it to zero and adding mutations later
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = F;

// Setting up chromosome structure: 25 chromosomes, 30 Mb each. Recombination rate is 1e-8 within chromosomes and 0.5 among chromosomes
	for (locus in 0:(nchrom-1)){
	geType=initializeGenomicElementType(locus, m1, 1.0);
	initializeGenomicElement(geType, locus*30000000, locus*30000000+29999999);
	}
	initializeMutationRate(0);
	lengths=rep(30000000,48);
   chrlistd=sort(rep(seq(1,24),2));
   breakpointd=lengths*chrlistd;
   offset=rep(c(1,0),24);
   breaks=c(breakpointd-offset,749999999);
   rates=c(1e-8,rep(c(0.5,1e-8),24));
	initializeRecombinationRate(rates,breaks);
}


// Random mating with a specified # of offspring. For each offspring randomly choose one male and one female parent. Recording parent IDs in order to output distribution of reproductive success later. In this reproduction call I am also outputting some info about # of breeding-age individuals and distribution of parentage.
reproduction(p1,"F") {
	K = sim.getValue("K");
	femalelist=NULL;
	malelist=NULL;
	for (i in seqLen(asInteger(K)))
	{
		female = p1.sampleIndividuals(1,sex="F",minAge=1);
		femalelist=c(femalelist,female.index);
		male = p1.sampleIndividuals(1,sex="M",minAge=1);
		malelist=c(malelist,male.index);
		p1.addCrossed(female, male);
	}
	breederdat=c("generation:",sim.generation,"num_breedingage_males:",sum(p1.individuals.sex == "M"),"num_breedingage_females:",sum(p1.individuals.sex == "F"));
	breedline=paste(breederdat,sep=" ");
	agedat=c("generation:",sim.generation,"age1:",sum(p1.individuals.age == 1),"age2:",sum(p1.individuals.age == 2),"age3:",sum(p1.individuals.age == 3),"age4:",sum(p1.individuals.age == 4),"age5:",sum(p1.individuals.age == 5),"age6:",sum(p1.individuals.age == 6),"age7:",sum(p1.individuals.age == 7),"age8:",sum(p1.individuals.age == 8));
	ageline=paste(agedat,sep=" ");
	maledat=c("generation:",sim.generation,"male_parents:",malelist);
	maleline=paste(maledat,sep=" ");
	femaledat=c("generation:",sim.generation,"female_parents:",femalelist);
	femaleline=paste(femaledat,sep=" ");
	writeFile(sim.getValue("BOF"),breedline,append=T);
	writeFile(sim.getValue("AOF"),ageline,append=T);
	writeFile(sim.getValue("MOF"),maleline,append=T);
	writeFile(sim.getValue("FOF"),femaleline,append=T);
	self.active = 0;
}

// First generation: set # of offspring and K to Nhistoric. Also had to set output files as simulation variable (not sure I had to do this in a previous version, but I think this is safer/ more reproducible?)  
1 early() {
	sim.setValue("K", Nhistoric);
	sim.setValue("AOF", AOutFile);
	sim.setValue("BOF", BOutFile);
	sim.setValue("MOF", MOutFile);
	sim.setValue("FOF", FOutFile);
	sim.setValue("TSOF", TSOutFile);
	sim.addSubpop("p1", Ninit);
p1.individuals.age=sample(c(rep(0,Nhistoric),rep(1,a1),rep(2,a2),rep(3,a3),rep(4,a4),rep(5,a5),rep(6,a6),rep(7,a7)),Ninit);
}

// Population decline: if simulation time is greater than or equal to Tdecline, exponential reduction in # of offspring. Can have a stable population if Tdecline is set to > 420.
early(){
	if (sim.generation > Tdecline) {
		sim.setValue("K",round(sim.getValue("K")*lambda));
		}
}

// Survival for overlapping generations based on life table 
early()
{		
	inds = p1.individuals;
	ages = inds.age;
	mortality = L[ages];
	survival = 1 - mortality;
	inds.fitnessScaling = survival;
}

// Tree sequence - remember individuals from each potential sampling time point. NOTE - may not have to remember all individuals. But tree-seq is cheap so remembering all may not be too onerous.

300 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

330 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

360 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

390 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

420 late() { sim.treeSeqRememberIndividuals(p1.individuals); }

// OUTPUT FILES for treeseq

420 late() { sim.treeSeqOutput(sim.getValue("TSOF")); }
